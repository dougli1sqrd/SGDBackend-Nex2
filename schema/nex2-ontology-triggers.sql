-- Generated by Ora2Pg, the Oracle database Schema converter, version 17.4
-- Copyright 2000-2016 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=sgd-nex2-db.stanford.edu;sid=SGD

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON


DROP TRIGGER IF EXISTS apo_audr ON nex.apo CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apo_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('APO', 'FORMAT_NAME', OLD.apo_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('APO', 'DISPLAY_NAME', OLD.apo_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('APO', 'OBJ_URL', OLD.apo_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

    IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO', 'SOURCE_ID', OLD.apo_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.apoid != NEW.apoid) THEN
        PERFORM nex.insertupdatelog('APO', 'APOID', OLD.apo_id, OLD.apoid, NEW.apoid, USER);
    END IF;

    IF (OLD.apo_namespace != NEW.apo_namespace) THEN
        PERFORM nex.insertupdatelog('APO', 'APO_NAMESPACE', OLD.apo_id, OLD.apo_namespace, NEW.apo_namespace, USER);
    END IF;

    IF (((OLD.namespace_group IS NULL) AND (NEW.namespace_group IS NOT NULL)) OR ((OLD.namespace_group IS NOT NULL) AND (NEW.namespace_group IS NULL)) OR (OLD.namespace_group != NEW.namespace_group)) THEN
        PERFORM nex.insertupdatelog('APO', 'NAMESPACE_GROUP', OLD.apo_id, OLD.namespace_group, NEW.namespace_group, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('APO', 'DESCRIPTION', OLD.apo_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.apo_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.apo_id || '[:]' || OLD.apo_namespace || '[:]' ||
             coalesce(OLD.namespace_group,'') || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('APO', OLD.apo_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apo_audr
AFTER UPDATE OR DELETE ON nex.apo FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apo_audr();

DROP TRIGGER IF EXISTS apo_biur ON nex.apo CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apo_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.apo_id != OLD.apo_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apo_biur
BEFORE INSERT OR UPDATE ON nex.apo FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apo_biur();

DROP TRIGGER IF EXISTS apoalias_audr ON nex.apo_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apoalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.apo_id != NEW.apo_id) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS', 'APO_ID', OLD.alias_id, OLD.apo_id, NEW.apo_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.apo_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('APO_ALIAS', OLD.alias_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apoalias_audr
AFTER UPDATE OR DELETE ON nex.apo_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apoalias_audr();

DROP TRIGGER IF EXISTS apoalias_biur ON nex.apo_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apoalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

   ELSIF (TG_OP = 'UPDATE') THEN

     IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
     END IF;

     IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
     END IF;

     IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
     END IF;

     RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apoalias_biur
BEFORE INSERT OR UPDATE ON nex.apo_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apoalias_biur();

DROP TRIGGER IF EXISTS aporelation_audr ON nex.apo_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_aporelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('APO_RELATION', OLD.relation_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER aporelation_audr
AFTER UPDATE OR DELETE ON nex.apo_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_aporelation_audr();

DROP TRIGGER IF EXISTS aporelation_biur ON nex.apo_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_aporelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER aporelation_biur
BEFORE INSERT OR UPDATE ON nex.apo_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_aporelation_biur();

DROP TRIGGER IF EXISTS apourl_audr ON nex.apo_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF TG_OP = 'UPDATE' THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('APO_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('APO_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
     END IF;

     IF (OLD.apo_id != NEW.apo_id) THEN
        PERFORM nex.insertupdatelog('APO_URL', 'APO_ID', OLD.url_id, OLD.apo_id, NEW.apo_id, USER);
     END IF;

     IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('APO_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
     END IF;

     RETURN NEW;
     
  ELSIF (TG_OP = 'DELETE') THEN

     v_row := OLD.url_id || '[:]' ||
              OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
              OLD.source_id || '[:]' || 
              OLD.apo_id || '[:]' || OLD.url_type || '[:]' ||
              OLD.date_created || '[:]' || OLD.created_by;

              PERFORM nex.insertdeletelog('APO_URL', OLD.url_id, v_row, USER);

      RETURN OLD;
   END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apourl_audr
AFTER UPDATE OR DELETE ON nex.apo_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apourl_audr();

DROP TRIGGER IF EXISTS apourl_biur ON nex.apo_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apourl_biur
BEFORE INSERT OR UPDATE ON nex.apo_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apourl_biur();


DROP TRIGGER IF EXISTS chebi_audr ON nex.chebi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebi_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('CHEBI', 'FORMAT_NAME', OLD.chebi_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('CHEBI', 'DISPLAY_NAME', OLD.chebi_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('CHEBI', 'OBJ_URL', OLD.chebi_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CHEBI', 'SOURCE_ID', OLD.chebi_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.chebiid != NEW.chebiid) THEN
        PERFORM nex.insertupdatelog('CHEBI', 'CHEBIID', OLD.chebi_id, OLD.chebiid, NEW.chebiid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('CHEBI', 'DESCRIPTION', OLD.chebi_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.chebi_id || '[:]' || OLD.format_name || '[:]' ||
  	         OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.chebiid || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('CHEBI', OLD.chebi_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebi_audr
AFTER UPDATE OR DELETE ON nex.chebi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebi_audr();

DROP TRIGGER IF EXISTS chebi_biur ON nex.chebi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebi_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.chebi_id != OLD.chebi_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebi_biur
BEFORE INSERT OR UPDATE ON nex.chebi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebi_biur();

DROP TRIGGER IF EXISTS chebialias_audr ON nex.chebi_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebialias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.chebi_id != NEW.chebi_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS', 'CHEBI_ID', OLD.alias_id, OLD.chebi_id, NEW.chebi_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' ||
             OLD.chebi_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('CHEBI_ALIAS', OLD.alias_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebialias_audr
AFTER UPDATE OR DELETE ON nex.chebi_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebialias_audr();

DROP TRIGGER IF EXISTS chebialias_biur ON nex.chebi_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebialias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebialias_biur
	BEFORE INSERT OR UPDATE ON nex.chebi_alias FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_chebialias_biur();

DROP TRIGGER IF EXISTS chebirelation_audr ON nex.chebi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebirelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF TG_OP = 'UPDATE' THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('CHEBI_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebirelation_audr
AFTER UPDATE OR DELETE ON nex.chebi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebirelation_audr();

DROP TRIGGER IF EXISTS chebirelation_biur ON nex.chebi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebirelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebirelation_biur
BEFORE INSERT OR UPDATE ON nex.chebi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebirelation_biur();

DROP TRIGGER IF EXISTS chebiurl_audr ON nex.chebi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebiurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.chebi_id != NEW.chebi_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL', 'CHEBI_ID', OLD.url_id, OLD.chebi_id, NEW.chebi_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.chebi_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('CHEBI_URL', OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebiurl_audr
AFTER UPDATE OR DELETE ON nex.chebi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebiurl_audr();

DROP TRIGGER IF EXISTS chebiurl_biur ON nex.chebi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebiurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebiurl_biur
BEFORE INSERT OR UPDATE ON nex.chebi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebiurl_biur();


DROP TRIGGER IF EXISTS disease_audr ON nex.disease CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_disease_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('DISEASE', 'FORMAT_NAME', OLD.disease_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DISEASE', 'DISPLAY_NAME', OLD.disease_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('DISEASE', 'OBJ_URL', OLD.disease_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE', 'SOURCE_ID', OLD.disease_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.doid != NEW.doid) THEN
        PERFORM nex.insertupdatelog('DISEASE', 'DOID', OLD.disease_id, OLD.doid, NEW.doid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('DISEASE', 'DESCRIPTION', OLD.disease_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.disease_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.doid || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('DISEASE', OLD.disease_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER disease_audr
AFTER UPDATE OR DELETE ON nex.disease FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_disease_audr();

DROP TRIGGER IF EXISTS disease_biur ON nex.disease CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_disease_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.disease_id != OLD.disease_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER disease_biur
BEFORE INSERT OR UPDATE ON nex.disease FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_disease_biur();

DROP TRIGGER IF EXISTS diseasealias_audr ON nex.disease_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasealias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.disease_id != NEW.disease_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS', 'DISEASE_ID', OLD.alias_id, OLD.disease_id, NEW.disease_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' ||
             OLD.disease_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('DISEASE_ALIAS', OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasealias_audr
AFTER UPDATE OR DELETE ON nex.disease_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasealias_audr();

DROP TRIGGER IF EXISTS diseasealias_biur ON nex.disease_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasealias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasealias_biur
BEFORE INSERT OR UPDATE ON nex.disease_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasealias_biur();

DROP TRIGGER IF EXISTS diseaserelation_audr ON nex.disease_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaserelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('DISEASE_RELATION', OLD.relation_id, v_row, USER);
    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaserelation_audr
AFTER UPDATE OR DELETE ON nex.disease_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaserelation_audr();

DROP TRIGGER IF EXISTS diseaserelation_biur ON nex.disease_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaserelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

      RETURN NEW; 

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaserelation_biur
BEFORE INSERT OR UPDATE ON nex.disease_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaserelation_biur();

DROP TRIGGER IF EXISTS diseaseurl_audr ON nex.disease_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaseurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.disease_id != NEW.disease_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL', 'DISEASE_ID', OLD.url_id, OLD.disease_id, NEW.disease_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.disease_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('DISEASE_URL', OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaseurl_audr
AFTER UPDATE OR DELETE ON nex.disease_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaseurl_audr();

DROP TRIGGER IF EXISTS diseaseurl_biur ON nex.disease_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaseurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;


END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaseurl_biur
BEFORE INSERT OR UPDATE ON nex.disease_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaseurl_biur();


DROP TRIGGER IF EXISTS ec_audr ON nex.ec CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ec_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('EC', 'FORMAT_NAME', OLD.ec_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EC', 'DISPLAY_NAME', OLD.ec_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EC', 'OBJ_URL', OLD.ec_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EC', 'SOURCE_ID', OLD.ec_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.ecid != NEW.ecid) THEN
        PERFORM nex.insertupdatelog('EC', 'ECID', OLD.ec_id, OLD.ecid, NEW.ecid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('EC', 'DESCRIPTION', OLD.ec_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.ec_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' ||
             OLD.ecid || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EC', OLD.ec_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ec_audr
AFTER UPDATE OR DELETE ON nex.ec FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ec_audr();

DROP TRIGGER IF EXISTS ec_biur ON nex.ec CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ec_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.ec_id != OLD.ec_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ec_biur
BEFORE INSERT OR UPDATE ON nex.ec FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ec_biur();

DROP TRIGGER IF EXISTS ecalias_audr ON nex.ec_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.ec_id != NEW.ec_id) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS', 'EC_ID', OLD.alias_id, OLD.ec_id, NEW.ec_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.ec_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EC_ALIAS', OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecalias_audr
AFTER UPDATE OR DELETE ON nex.ec_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecalias_audr();

DROP TRIGGER IF EXISTS ecalias_biur ON nex.ec_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecalias_biur
BEFORE INSERT OR UPDATE ON nex.ec_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecalias_biur();

DROP TRIGGER IF EXISTS ecurl_audr ON nex.ec_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EC_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EC_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EC_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.ec_id != NEW.ec_id) THEN
        PERFORM nex.insertupdatelog('EC_URL', 'EC_ID', OLD.url_id, OLD.ec_id, NEW.ec_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('EC_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.ec_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EC_URL', OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecurl_audr
AFTER UPDATE OR DELETE ON nex.ec_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecurl_audr();

DROP TRIGGER IF EXISTS ecurl_biur ON nex.ec_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecurl_biur
BEFORE INSERT OR UPDATE ON nex.ec_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecurl_biur();


DROP TRIGGER IF EXISTS eco_audr ON nex.eco CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_eco_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('ECO', 'FORMAT_NAME', OLD.eco_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('ECO', 'DISPLAY_NAME', OLD.eco_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('ECO', 'OBJ_URL', OLD.eco_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO', 'SOURCE_ID', OLD.eco_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.ecoid != NEW.ecoid) THEN
        PERFORM nex.insertupdatelog('ECO', 'ECOID', OLD.eco_id, OLD.ecoid, NEW.ecoid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('ECO', 'DESCRIPTION', OLD.eco_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.eco_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.ecoid || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('ECO', OLD.eco_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER eco_audr
AFTER UPDATE OR DELETE ON nex.eco FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_eco_audr();

DROP TRIGGER IF EXISTS eco_biur ON nex.eco CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_eco_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.eco_id != OLD.eco_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER eco_biur
BEFORE INSERT OR UPDATE ON nex.eco FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_eco_biur();

DROP TRIGGER IF EXISTS ecoalias_audr ON nex.eco_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecoalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.eco_id != NEW.eco_id) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS', 'ECO_ID', OLD.alias_id, OLD.eco_id, NEW.eco_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.eco_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('ECO_ALIAS', OLD.alias_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecoalias_audr
AFTER UPDATE OR DELETE ON nex.eco_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecoalias_audr();

DROP TRIGGER IF EXISTS ecoalias_biur ON nex.eco_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecoalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecoalias_biur
BEFORE INSERT OR UPDATE ON nex.eco_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecoalias_biur();

DROP TRIGGER IF EXISTS ecorelation_audr ON nex.eco_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecorelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

     RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('ECO_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecorelation_audr
AFTER UPDATE OR DELETE ON nex.eco_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecorelation_audr();

DROP TRIGGER IF EXISTS ecorelation_biur ON nex.eco_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecorelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecorelation_biur
BEFORE INSERT OR UPDATE ON nex.eco_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecorelation_biur();

DROP TRIGGER IF EXISTS ecourl_audr ON nex.eco_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('ECO_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('ECO_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.eco_id != NEW.eco_id) THEN
        PERFORM nex.insertupdatelog('ECO_URL', 'ECO_ID', OLD.url_id, OLD.eco_id, NEW.eco_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('ECO_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' ||
             OLD.eco_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('ECO_URL', OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecourl_audr
AFTER UPDATE OR DELETE ON nex.eco_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecourl_audr();

DROP TRIGGER IF EXISTS ecourl_biur ON nex.eco_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecourl_biur
BEFORE INSERT OR UPDATE ON nex.eco_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecourl_biur();


DROP TRIGGER IF EXISTS edam_audr ON nex.edam CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edam_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('EDAM', 'FORMAT_NAME', OLD.edam_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EDAM', 'DISPLAY_NAME', OLD.edam_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EDAM', 'OBJ_URL', OLD.edam_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM', 'SOURCE_ID', OLD.edam_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.edamid != NEW.edamid) THEN
        PERFORM nex.insertupdatelog('EDAM', 'EDAMID', OLD.edam_id, OLD.edamid, NEW.edamid, USER);
    END IF;

     IF (OLD.edam_namespace != NEW.edam_namespace) THEN
        PERFORM nex.insertupdatelog('EDAM', 'EDAM_NAMESPACE', OLD.edam_id, OLD.edam_namespace, NEW.edam_namespace, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('EDAM', 'DESCRIPTION', OLD.edam_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.edam_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.edamid || '[:]' ||
             OLD.edam_namespace || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM', OLD.edam_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edam_audr
AFTER UPDATE OR DELETE ON nex.edam FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edam_audr();

DROP TRIGGER IF EXISTS edam_biur ON nex.edam CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edam_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.edam_id != OLD.edam_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edam_biur
BEFORE INSERT OR UPDATE ON nex.edam FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edam_biur();

DROP TRIGGER IF EXISTS edamalias_audr ON nex.edam_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.edam_id != NEW.edam_id) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS', 'EDAM_ID', OLD.alias_id, OLD.edam_id, NEW.edam_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.edam_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM_ALIAS', OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamalias_audr
AFTER UPDATE OR DELETE ON nex.edam_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamalias_audr();

DROP TRIGGER IF EXISTS edamalias_biur ON nex.edam_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamalias_biur
BEFORE INSERT OR UPDATE ON nex.edam_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamalias_biur();

DROP TRIGGER IF EXISTS edamrelation_audr ON nex.edam_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamrelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

     IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
     END IF;

     RETURN NEW;
     
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamrelation_audr
AFTER UPDATE OR DELETE ON nex.edam_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamrelation_audr();

DROP TRIGGER IF EXISTS edamrelation_biur ON nex.edam_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamrelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamrelation_biur
BEFORE INSERT OR UPDATE ON nex.edam_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamrelation_biur();

DROP TRIGGER IF EXISTS edamurl_audr ON nex.edam_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EDAM_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EDAM_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.edam_id != NEW.edam_id) THEN
        PERFORM nex.insertupdatelog('EDAM_URL', 'EDAM_ID', OLD.url_id, OLD.edam_id, NEW.edam_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('EDAM_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.edam_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM_URL', OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamurl_audr
AFTER UPDATE OR DELETE ON nex.edam_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamurl_audr();

DROP TRIGGER IF EXISTS edamurl_biur ON nex.edam_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamurl_biur
BEFORE INSERT OR UPDATE ON nex.edam_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamurl_biur();


DROP TRIGGER IF EXISTS go_audr ON nex.go CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_go_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('GO', 'FORMAT_NAME', OLD.go_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('GO', 'DISPLAY_NAME', OLD.go_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('GO', 'OBJ_URL', OLD.go_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GO', 'SOURCE_ID', OLD.go_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.goid != NEW.goid) THEN
        PERFORM nex.insertupdatelog('GO', 'GOID', OLD.go_id, OLD.goid, NEW.goid, USER);
    END IF;

     IF (OLD.go_namespace != NEW.go_namespace) THEN
        PERFORM nex.insertupdatelog('GO', 'GO_NAMESPACE', OLD.go_id, OLD.go_namespace, NEW.go_namespace, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('GO', 'DESCRIPTION', OLD.go_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.go_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.goid || '[:]' ||
             OLD.go_namespace || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('GO', OLD.go_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER go_audr
	AFTER UPDATE OR DELETE ON nex.go FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_go_audr();

DROP TRIGGER IF EXISTS go_biur ON nex.go CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_go_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.go_id != OLD.go_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER go_biur
BEFORE INSERT OR UPDATE ON nex.go FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_go_biur();

DROP TRIGGER IF EXISTS goalias_audr ON nex.go_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
    IF (TG_OP = 'UPDATE') THEN

      IF (OLD.display_name != NEW.display_name)THEN
          PERFORM insertupdatelog('GO_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
      END IF;

      IF (OLD.source_id != NEW.source_id) THEN
	  PERFORM insertupdatelog('GO_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
     END IF;

      IF (OLD.go_id != NEW.go_id) THEN
	 PERFORM insertupdatelog('GO_ALIAS', 'GO_ID', OLD.alias_id, OLD.go_id, NEW.go_id, USER);
      END IF;

     IF (OLD.alias_type != NEW.alias_type) THEN
 	 PERFORM insertupdatelog('GO_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
     END IF;

     RETURN NEW;
     
  ELSIF (TG_OP = 'DELETE') THEN

     v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' ||
              OLD.source_id || '[:]' || OLD.go_id || '[:]' ||
              OLD.alias_type || '[:]' ||
              OLD.date_created || '[:]' || OLD.created_by;

              PERFORM insertdeletelog('GO_ALIAS', OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goalias_audr
AFTER UPDATE OR DELETE ON nex.go_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goalias_audr();

DROP TRIGGER IF EXISTS goalias_biur ON nex.go_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goalias_biur
BEFORE INSERT OR UPDATE ON nex.go_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goalias_biur();

DROP TRIGGER IF EXISTS gorelation_audr ON nex.go_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gorelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('GO_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gorelation_audr
AFTER UPDATE OR DELETE ON nex.go_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gorelation_audr();

DROP TRIGGER IF EXISTS gorelation_biur ON nex.go_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gorelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gorelation_biur
BEFORE INSERT OR UPDATE ON nex.go_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gorelation_biur();

DROP TRIGGER IF EXISTS gourl_audr ON nex.go_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('GO_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('GO_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GO_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.go_id != NEW.go_id) THEN
        PERFORM nex.insertupdatelog('GO_URL', 'GO_ID', OLD.url_id, OLD.go_id, NEW.go_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('GO_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.go_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('GO_URL', OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gourl_audr
AFTER UPDATE OR DELETE ON nex.go_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gourl_audr();

DROP TRIGGER IF EXISTS gourl_biur ON nex.go_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gourl_biur
BEFORE INSERT OR UPDATE ON nex.go_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gourl_biur();


DROP TRIGGER IF EXISTS keyword_audr ON nex.keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_keyword_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('KEYWORD', 'FORMAT_NAME', OLD.keyword_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('KEYWORD', 'DISPLAY_NAME', OLD.keyword_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('KEYWORD', 'OBJ_URL', OLD.keyword_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('KEYWORD', 'SOURCE_ID', OLD.keyword_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('KEYWORD', 'DESCRIPTION', OLD.keyword_id, OLD.description, NEW.description, USER);
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.keyword_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('KEYWORD', OLD.keyword_id, v_row, USER);
    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER keyword_audr
AFTER UPDATE OR DELETE ON nex.keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_keyword_audr();

DROP TRIGGER IF EXISTS keyword_biur ON nex.keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_keyword_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.keyword_id != OLD.keyword_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;
    
    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER keyword_biur
BEFORE INSERT OR UPDATE ON nex.keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_keyword_biur();


DROP TRIGGER IF EXISTS obi_audr ON nex.obi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obi_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('OBI', 'FORMAT_NAME', OLD.obi_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('OBI', 'DISPLAY_NAME', OLD.obi_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('OBI', 'OBJ_URL', OLD.obi_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('OBI', 'SOURCE_ID', OLD.obi_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.obiid != NEW.obiid) THEN
        PERFORM nex.insertupdatelog('OBI', 'OBIID', OLD.obi_id, OLD.obiid, NEW.obiid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('OBI', 'DESCRIPTION', OLD.obi_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.obi_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.obiid || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('OBI', OLD.obi_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obi_audr
AFTER UPDATE OR DELETE ON nex.obi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obi_audr();

DROP TRIGGER IF EXISTS obi_biur ON nex.obi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obi_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.obi_id != OLD.obi_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obi_biur
BEFORE INSERT OR UPDATE ON nex.obi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obi_biur();

DROP TRIGGER IF EXISTS obirelation_audr ON nex.obi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obirelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('OBI_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obirelation_audr
AFTER UPDATE OR DELETE ON nex.obi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obirelation_audr();

DROP TRIGGER IF EXISTS obirelation_biur ON nex.obi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obirelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obirelation_biur
BEFORE INSERT OR UPDATE ON nex.obi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obirelation_biur();

DROP TRIGGER IF EXISTS obiurl_audr ON nex.obi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obiurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('OBI_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('OBI_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('OBI_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.obi_id != NEW.obi_id) THEN
        PERFORM nex.insertupdatelog('OBI_URL', 'OBI_ID', OLD.url_id, OLD.obi_id, NEW.obi_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('OBI_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.obi_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('OBI_URL', OLD.url_id, v_row, USER);

      RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obiurl_audr
AFTER UPDATE OR DELETE ON nex.obi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obiurl_audr();

DROP TRIGGER IF EXISTS obiurl_biur ON nex.obi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obiurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obiurl_biur
BEFORE INSERT OR UPDATE ON nex.obi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obiurl_biur();


DROP TRIGGER IF EXISTS psimod_audr ON nex.psimod CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimod_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('PSIMOD', 'FORMAT_NAME', OLD.psimod_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('PSIMOD', 'DISPLAY_NAME', OLD.psimod_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('PSIMOD', 'OBJ_URL', OLD.psimod_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD', 'SOURCE_ID', OLD.psimod_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.psimodid != NEW.psimodid) THEN
        PERFORM nex.insertupdatelog('PSIMOD', 'PSIMODID', OLD.psimod_id, OLD.psimodid, NEW.psimodid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('PSIMOD', 'DESCRIPTION', OLD.psimod_id, OLD.description, NEW.description, USER);
    END IF;

     RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.psimod_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.psimodid || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMOD', OLD.psimod_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimod_audr
AFTER UPDATE OR DELETE ON nex.psimod FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimod_audr();

DROP TRIGGER IF EXISTS psimod_biur ON nex.psimod CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimod_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
              PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.psimod_id != OLD.psimod_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimod_biur
BEFORE INSERT OR UPDATE ON nex.psimod FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimod_biur();

DROP TRIGGER IF EXISTS psimodrelation_audr ON nex.psimod_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodrelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMOD_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodrelation_audr
AFTER UPDATE OR DELETE ON nex.psimod_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodrelation_audr();

DROP TRIGGER IF EXISTS psimodrelation_biur ON nex.psimod_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodrelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodrelation_biur
BEFORE INSERT OR UPDATE ON nex.psimod_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodrelation_biur();

DROP TRIGGER IF EXISTS psimodurl_audr ON nex.psimod_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.psimod_id != NEW.psimod_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL', 'PSIMOD_ID', OLD.url_id, OLD.psimod_id, NEW.psimod_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.psimod_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMOD_URL', OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodurl_audr
AFTER UPDATE OR DELETE ON nex.psimod_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodurl_audr();

DROP TRIGGER IF EXISTS psimodurl_biur ON nex.psimod_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodurl_biur
BEFORE INSERT OR UPDATE ON nex.psimod_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodurl_biur();


DROP TRIGGER IF EXISTS ro_audr ON nex.ro CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ro_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('RO', 'FORMAT_NAME', OLD.ro_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('RO', 'DISPLAY_NAME', OLD.ro_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('RO', 'OBJ_URL', OLD.ro_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('RO', 'SOURCE_ID', OLD.ro_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.roid != NEW.roid) THEN
        PERFORM nex.insertupdatelog('RO', 'ROID', OLD.ro_id, OLD.roid, NEW.roid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('RO', 'DESCRIPTION', OLD.ro_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.ro_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.ro_id || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('RO', OLD.ro_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ro_audr
AFTER UPDATE OR DELETE ON nex.ro FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ro_audr();

DROP TRIGGER IF EXISTS ro_biur ON nex.ro CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ro_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.ro_id != OLD.ro_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';
 
CREATE TRIGGER ro_biur
BEFORE INSERT OR UPDATE ON nex.ro FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ro_biur();

DROP TRIGGER IF EXISTS rorelation_audr ON nex.ro_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rorelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('RO_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('RO_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('RO_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.relation_type != NEW.relation_type) THEN
        PERFORM nex.insertupdatelog('RO_RELATION', 'RELATION_TYPE', OLD.relation_id, OLD.relation_type, NEW.relation_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.relation_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('RO_RELATION', OLD.relation_id, v_row, USER);
     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER rorelation_audr
AFTER UPDATE OR DELETE ON nex.ro_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_rorelation_audr();

DROP TRIGGER IF EXISTS rorelation_biur ON nex.ro_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rorelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER rorelation_biur
BEFORE INSERT OR UPDATE ON nex.ro_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_rorelation_biur();

DROP TRIGGER IF EXISTS rourl_audr ON nex.ro_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('RO_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('RO_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('RO_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('RO_URL', 'RO_ID', OLD.url_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('RO_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.ro_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('RO_URL', OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER rourl_audr
AFTER UPDATE OR DELETE ON nex.ro_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_rourl_audr();

DROP TRIGGER IF EXISTS rourl_biur ON nex.ro_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER rourl_biur
BEFORE INSERT OR UPDATE ON nex.ro_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_rourl_biur();


DROP TRIGGER IF EXISTS so_audr ON nex.so CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_so_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('SO', 'FORMAT_NAME', OLD.so_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('SO', 'DISPLAY_NAME', OLD.so_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('SO', 'OBJ_URL', OLD.so_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO', 'SOURCE_ID', OLD.so_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.soid != NEW.soid) THEN
        PERFORM nex.insertupdatelog('SO', 'SOID', OLD.so_id, OLD.soid, NEW.soid, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('SO', 'DESCRIPTION', OLD.so_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.so_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.soid || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO', OLD.so_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER so_audr
AFTER UPDATE OR DELETE ON nex.so FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_so_audr();

DROP TRIGGER IF EXISTS so_biur ON nex.so CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_so_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.so_id != OLD.so_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER so_biur
BEFORE INSERT OR UPDATE ON nex.so FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_so_biur();

DROP TRIGGER IF EXISTS soalias_audr ON nex.so_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_soalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.so_id != NEW.so_id) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS', 'SO_ID', OLD.alias_id, OLD.so_id, NEW.so_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' ||
             OLD.so_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO_ALIAS', OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER soalias_audr
AFTER UPDATE OR DELETE ON nex.so_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_soalias_audr();

DROP TRIGGER IF EXISTS soalias_biur ON nex.so_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_soalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER soalias_biur
BEFORE INSERT OR UPDATE ON nex.so_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_soalias_biur();

DROP TRIGGER IF EXISTS sorelation_audr ON nex.so_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sorelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sorelation_audr
AFTER UPDATE OR DELETE ON nex.so_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sorelation_audr();

DROP TRIGGER IF EXISTS sorelation_biur ON nex.so_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sorelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sorelation_biur
BEFORE INSERT OR UPDATE ON nex.so_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sorelation_biur();

DROP TRIGGER IF EXISTS sourl_audr ON nex.so_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('SO_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('SO_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.so_id != NEW.so_id) THEN
        PERFORM nex.insertupdatelog('SO_URL', 'SO_ID', OLD.url_id, OLD.so_id, NEW.so_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('SO_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.so_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO_URL', OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sourl_audr
AFTER UPDATE OR DELETE ON nex.so_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sourl_audr();

DROP TRIGGER IF EXISTS sourl_biur ON nex.so_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sourl_biur
BEFORE INSERT OR UPDATE ON nex.so_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sourl_biur();


DROP TRIGGER IF EXISTS taxonomy_audr ON nex.taxonomy CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomy_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY', 'FORMAT_NAME', OLD.taxonomy_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY', 'DISPLAY_NAME', OLD.taxonomy_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('TAXONOMY', 'OBJ_URL', OLD.taxonomy_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY', 'SOURCE_ID', OLD.taxonomy_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.taxid != NEW.taxid) THEN
        PERFORM nex.insertupdatelog('TAXONOMY', 'TAXID', OLD.taxonomy_id, OLD.taxid, NEW.taxid, USER);
    END IF;

    IF (((OLD.common_name IS NULL) AND (NEW.common_name IS NOT NULL)) OR ((OLD.common_name IS NOT NULL) AND (NEW.common_name IS NULL)) OR (OLD.common_name != NEW.common_name)) THEN
        PERFORM nex.insertupdatelog('TAXONOMY', 'COMMON_NAME', OLD.taxonomy_id, OLD.common_name, NEW.common_name, USER);
    END IF;

    IF (OLD.rank != NEW.rank) THEN
        PERFORM nex.insertupdatelog('TAXONOMY', 'RANK', OLD.taxonomy_id, OLD.rank, NEW.rank, USER);
    END IF;

    RETURN NEW;
 
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.taxonomy_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxid || '[:]' ||
             coalesce(OLD.common_name,'') || '[:]' || OLD.rank || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY', OLD.taxonomy_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomy_audr
AFTER UPDATE OR DELETE ON nex.taxonomy FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomy_audr();

DROP TRIGGER IF EXISTS taxonomy_biur ON nex.taxonomy CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomy_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.taxonomy_id != OLD.taxonomy_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomy_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomy_biur();

DROP TRIGGER IF EXISTS taxonomyalias_audr ON nex.taxonomy_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS', 'DISPLAY_NAME', OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS', 'SOURCE_ID', OLD.alias_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS', 'TAXONOMY_ID', OLD.alias_id, OLD.taxonomy_id, NEW.taxonomy_id, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS', 'ALIAS_TYPE', OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.taxonomy_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY_ALIAS', OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyalias_audr
AFTER UPDATE OR DELETE ON nex.taxonomy_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyalias_audr();

DROP TRIGGER IF EXISTS taxonomyalias_biur ON nex.taxonomy_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyalias_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyalias_biur();

DROP TRIGGER IF EXISTS taxonomyrelation_audr ON nex.taxonomy_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyrelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION', 'SOURCE_ID', OLD.relation_id, OLD.source_id, NEW.source_id, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION', 'PARENT_ID', OLD.relation_id, OLD.parent_id, NEW.parent_id, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION', 'CHILD_ID', OLD.relation_id, OLD.child_id, NEW.child_id, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION', 'RO_ID', OLD.relation_id, OLD.ro_id, NEW.ro_id, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY_RELATION', OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyrelation_audr
AFTER UPDATE OR DELETE ON nex.taxonomy_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyrelation_audr();

DROP TRIGGER IF EXISTS taxonomyrelation_biur ON nex.taxonomy_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyrelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyrelation_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyrelation_biur();

DROP TRIGGER IF EXISTS taxonomyurl_audr ON nex.taxonomy_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL', 'DISPLAY_NAME', OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL', 'OBJ_URL', OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL', 'SOURCE_ID', OLD.url_id, OLD.source_id, NEW.source_id, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL', 'TAXONOMY_ID', OLD.url_id, OLD.taxonomy_id, NEW.taxonomy_id, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type)  THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL', 'URL_TYPE', OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' ||  OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.taxonomy_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY_URL', OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;
  
END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyurl_audr
AFTER UPDATE OR DELETE ON nex.taxonomy_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyurl_audr();

DROP TRIGGER IF EXISTS taxonomyurl_biur ON nex.taxonomy_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$  LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyurl_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyurl_biur();
